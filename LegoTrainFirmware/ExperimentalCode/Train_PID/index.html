<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote Train Control</title>
    <style>
        :root{
            --primary-color: #cbcdd8a2;
            --secondary-color: #ffae00;
            --secondary-color-shade1: #90ee38;
            --secondary-color-shade2: #f39e2e;
            --secondary-color-shade3: #880d0d;
            --deactivated-color: #c9b68e;
        }
        body{
            display:flex;
            justify-content:center;
            align-items:center;
            height:100vh;
            margin:0;
            font-family:Arial,sans-serif;
            background-color:var(--primary-color);
        }
        .container{
            display:flex;
            flex-direction:column;
            width:100%;
            height:100%;
        }
        .top-half{
            display:flex;
            flex-direction:column;
            width:100%;
            height:50%;
        }
        .buttons{
            display:flex;
            justify-content:space-around;
            align-items:center;
            height:30%;
        }
        .mode-button{
            width:20%;
            height:80%;
            background-color:var(--secondary-color);
            color:#fff;
            border:none;
            border-radius:5px;
            font-size:1.2em;
            cursor:pointer;
        }
        .bars{
            display:flex;
            justify-content:space-around;
            align-items:center;
            height:70%;
        }
        .bar{
            width:20%;
            height:80%;
            background-color:#f0f0f0;
            border:2px solid #ccc;
            border-radius:10px;
            position:relative;
        }
        .setpoint-value{
            width:100%;
            height:20%;
            background-color:var(--secondary-color-shade1);
            position:absolute;
            bottom:0;
            border-radius:10px 10px 0 0;
        }
        .input-value{
            width:100%;
            height:20%;
            background-color:var(--secondary-color-shade2);
            position:absolute;
            bottom:0;
            border-radius:10px 10px 0 0;
        }
        .output-value{
            width:100%;
            height:20%;
            background-color:var(--secondary-color-shade3);
            position:absolute;
            bottom:0;
            border-radius:10px 10px 0 0;
        }
        .bottom-left-quarter{
            display:flex;
            justify-content:center;
            align-items:center;
            width:50%;
            height:50%;
            position:absolute;
            bottom:0;
            left:0;
        }
        .bottom-right-quarter{
            display:flex;
            justify-content:center;
            align-items:center;
            flex-direction:column;
            width:50%;
            height:50%;
            position:absolute;
            bottom:0;
            right:0;
        }
        .bottom-right-button{
            width:80%;
            height:20%;
            background-color:var(--secondary-color);
            color:#fff;
            border:none;
            border-radius:5px;
            font-size:1.2em;
            cursor:pointer;
            margin:5px 0;
        }
        .joystick-container{
            width:100px;
            height:300px;
            background-color:#f0f0f0;
            border:2px solid #ccc;
            border-radius:10px;
            position:relative;
        }
        .joystick-container::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 10%;
            right: 10%;
            height: 2px;
            background-color: #999;
            transform: translateY(-1px);
        }
        .joystick-container::after {
            content: '';
            position: absolute;
            top: calc(50% - 15px);
            left: 10%;
            right: 10%;
            height: 30px;
            background-color: rgba(153, 153, 153, 0.2);
            border-radius: 3px;
        }
        .joystick{
            width:80px;
            height:80px;
            background-color:var(--secondary-color);
            border-radius:50%;
            position:absolute;
            left:50%;
            transform:translate(-50%);
            cursor:pointer;
        }
        .toggle-button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: 5px;
            padding: 8px 16px;
            margin-left: 10px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            height: 80%;
        }
        .toggle-button:hover {
            background-color: var(--secondary-color-shade1);
        }
        #graphCanvas {
            width: 100%;
            height: 100%;
            background-color: #f8f8f8;
            border: 2px solid #ccc;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="top-half">
            <div class="buttons">
                <button class="mode-button" id="btn_mode1">Manual</button>
                <button class="mode-button" id="btn_mode2">Target Output</button>
                <button class="mode-button" id="btn_mode3">Target Speed</button>
                <button class="mode-button" id="btn_mode4">Full Auto</button>
                <button class="toggle-button" id="displayToggle">Show Graph</button>
            </div>
            <div class="bars" id="barsContainer">
                <div class="bar">
                    <div class="setpoint-value" id="bar_setpoint"></div>
                </div>
                <div class="bar">
                    <div class="input-value" id="bar_input"></div>
                </div>
                <div class="bar">
                    <div class="output-value" id="bar_output"></div>
                </div>
            </div>
            <canvas id="graphCanvas" width="800" height="200"></canvas>
            <div style="display: flex; justify-content: space-around; margin-top: 5px;" id="barLabels">
                <div style="text-align: center; width: 20%; font-size: 0.9em; font-weight: bold; color: #333;">
                    Setpoint
                </div>
                <div style="text-align: center; width: 20%; font-size: 0.9em; font-weight: bold; color: #333;">
                    Input
                </div>
                <div style="text-align: center; width: 20%; font-size: 0.9em; font-weight: bold; color: #333;">
                    Output
                </div>
            </div>
        </div>
        <div class="bottom-left-quarter">
            <div class="joystick-container">
                <div class="joystick" id="joystick"></div>
            </div>
            <div style="text-align: center; margin-top: 10px; font-weight: bold; font-size: 1.1em;">
                <span style="color: #333;">Value: </span>
                <span id="joystick-value" style="color: #ffae00; font-family: monospace;">0</span>
            </div>
        </div>
        <div class="bottom-right-quarter">
            <p style="color: #333; text-align: center; margin-bottom: 20px;">
                Joystick: Up = Forward (+100), Down = Backward (-100)<br>
                Range: -100 to +100 with deadband
            </p>
            <button class="bottom-right-button" style="background-color: red;" id="stop_btn">STOP</button>
        </div>
    </div>
    <script>
        var modeButtons = ["btn_mode1","btn_mode2","btn_mode3","btn_mode4"];
        var selectedMode = 0;
        var modeCallback = null;
        
        // Global variable to track current setpoint
        var currentSetpoint = 0;
        
        // Data storage for graph (latest 100 values)
        var dataHistory = {
            setpoint: [],
            input: [],
            output: [],
            maxLength: 100
        };
        var showGraph = false;
        var canvas, ctx;
        
        function addDataPoint(setpoint, input, output) {
            dataHistory.setpoint.push(setpoint);
            dataHistory.input.push(input);
            dataHistory.output.push(output);
            
            // Keep only latest 100 values
            if(dataHistory.setpoint.length > dataHistory.maxLength) {
                dataHistory.setpoint.shift();
                dataHistory.input.shift();
                dataHistory.output.shift();
            }
        }
        
        function drawGraph() {
            if(!canvas || !ctx || !showGraph) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Clear canvas
            ctx.fillStyle = '#f8f8f8';
            ctx.fillRect(0, 0, width, height);
            
            // Draw grid
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.beginPath();
            
            // Horizontal lines
            for(let i = 0; i <= 10; i++) {
                const y = padding + (i * graphHeight / 10);
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
            }
            
            // Vertical lines
            for(let i = 0; i <= 10; i++) {
                const x = padding + (i * graphWidth / 10);
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
            }
            ctx.stroke();
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw Y-axis labels
            const allData = [...dataHistory.setpoint, ...dataHistory.input, ...dataHistory.output];
            const minVal = Math.min(...allData, -100);
            const maxVal = Math.max(...allData, 100);
            const range = maxVal - minVal;
            
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            for(let i = 0; i <= 10; i++) {
                const y = padding + (i * graphHeight / 10);
                const value = maxVal - (i / 10) * range;
                ctx.fillText(Math.round(value), padding - 8, y);
            }
            
            // Reset text alignment and baseline
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
            
            // Draw data lines
            if(dataHistory.setpoint.length > 1) {
                drawLine(dataHistory.setpoint, '#90ee38', 'Setpoint');
                drawLine(dataHistory.input, '#f39e2e', 'Input');
                drawLine(dataHistory.output, '#880d0d', 'Output');
            }
            
            // Draw legend
            drawLegend();
        }
        
        function drawLine(data, color, label) {
            if(data.length < 2) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            const graphWidth = width - 2 * padding;
            const graphHeight = height - 2 * padding;
            
            // Find min/max for scaling
            const allData = [...dataHistory.setpoint, ...dataHistory.input, ...dataHistory.output];
            const minVal = Math.min(...allData, -100);
            const maxVal = Math.max(...allData, 100);
            const range = maxVal - minVal;
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for(let i = 0; i < data.length; i++) {
                const x = padding + (i / (dataHistory.maxLength - 1)) * graphWidth;
                const y = height - padding - ((data[i] - minVal) / range) * graphHeight;
                
                if(i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
        }
        
        function drawLegend() {
            const legendX = canvas.width - 150;
            const legendY = 20;
            
            ctx.font = '12px Arial';
            
            // Setpoint
            ctx.fillStyle = '#90ee38';
            ctx.fillRect(legendX, legendY, 15, 3);
            ctx.fillStyle = '#333';
            ctx.fillText('Setpoint', legendX + 20, legendY + 10);
            
            // Input
            ctx.fillStyle = '#f39e2e';
            ctx.fillRect(legendX, legendY + 20, 15, 3);
            ctx.fillStyle = '#333';
            ctx.fillText('Input', legendX + 20, legendY + 30);
            
            // Output
            ctx.fillStyle = '#880d0d';
            ctx.fillRect(legendX, legendY + 40, 15, 3);
            ctx.fillStyle = '#333';
            ctx.fillText('Output', legendX + 20, legendY + 50);
        }
        
        function toggleDisplay() {
            showGraph = !showGraph;
            const barsContainer = document.getElementById('barsContainer');
            const barLabels = document.getElementById('barLabels');
            const graphCanvas = document.getElementById('graphCanvas');
            const toggleButton = document.getElementById('displayToggle');
            
            if(showGraph) {
                barsContainer.style.display = 'none';
                barLabels.style.display = 'none';
                graphCanvas.style.display = 'block';
                toggleButton.textContent = 'Show Bars';
                
                // Initialize canvas if not done yet
                if(!canvas) {
                    canvas = graphCanvas;
                    ctx = canvas.getContext('2d');
                }
                drawGraph();
            } else {
                barsContainer.style.display = 'flex';
                barLabels.style.display = 'flex';
                graphCanvas.style.display = 'none';
                toggleButton.textContent = 'Show Graph';
            }
        }
        
        function initModeSelector(){
            modeButtons.forEach(function(buttonId){
                document.getElementById(buttonId).addEventListener("click", function(){
                    onModeButtonClicked(buttonId);
                });
            });
            
            // Add toggle button event listener
            document.getElementById('displayToggle').addEventListener('click', toggleDisplay);
            
            setModeSelection(0);
        }
        
        function onModeButtonClicked(buttonId){
            selectedMode = modeButtons.indexOf(buttonId);
            modeButtons.forEach(function(id){
                if(modeCallback != null){
                    modeCallback(selectedMode);
                }
                if(id == buttonId){
                    document.getElementById(id).style = "background-color: var(--secondary-color)";
                } else {
                    document.getElementById(id).style = "background-color: var(--deactivated-color)";
                }
            });
        }
        
        function getSelectedMode(){
            return selectedMode;
        }
        
        function setModeSelection(mode){
            onModeButtonClicked(modeButtons[mode]);
        }
        
        function setModeCallback(callback){
            modeCallback = callback;
        }
        
        const joystick = document.getElementById("joystick");
        const joystickContainer = document.querySelector(".joystick-container");
        var stopCallback = null;
        
        function resetJoystickPosition(){
            // Center the joystick in the container
            const centerY = (joystickContainer.offsetHeight - joystick.offsetHeight) / 2;
            joystick.style.top = `${centerY}px`;
        }
        
        function setStopCallback(callback){
            stopCallback = callback;
        }
        
        function initJoystick(){
            window.addEventListener('load', resetJoystickPosition);
            
            // Initialize stop button
            document.getElementById("stop_btn").addEventListener("click", function(){
                if(stopCallback != null){
                    stopCallback();
                }
                resetJoystickPosition();
            });
            
            // Add touch events to both joystick and container
            function addTouchEvents(element) {
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    // Move joystick to touch position immediately
                    moveJoystick(e.touches[0]);
                    
                    const handleTouchMove = (e) => {
                        moveJoystick(e.touches[0]);
                    };
                    document.addEventListener('touchmove', handleTouchMove);
                    document.addEventListener('touchend', () => {
                        document.removeEventListener('touchmove', handleTouchMove);
                    }, { once: true });
                });
            }
            
            // Add mouse events to both joystick and container
            function addMouseEvents(element) {
                element.addEventListener('mousedown', (e) => {
                    // Move joystick to click position immediately
                    moveJoystick(e);
                    
                    const handleMouseMove = (e) => {
                        moveJoystick(e);
                    };
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', () => {
                        document.removeEventListener('mousemove', handleMouseMove);
                    }, { once: true });
                });
            }
            
            // Apply events to both joystick and container
            addTouchEvents(joystick);
            addTouchEvents(joystickContainer);
            addMouseEvents(joystick);
            addMouseEvents(joystickContainer);
        }

        function getJoystickValue(){
            var value = getJoystickRawValue();
            
            // Apply deadband (5% around center)
            if(Math.abs(value) < 5) {
                value = 0;
            }
            
            console.log("Joystick value: " + value);
            return value;
        }
        
        function getJoystickRawValue(){
            const containerRect = joystickContainer.getBoundingClientRect();
            const joystickRect = joystick.getBoundingClientRect();
            const containerCenter = containerRect.top + containerRect.height / 2;
            const joystickCenter = joystickRect.top + joystickRect.height / 2;
            
            // Use the full available movement range for calculation
            const maxMovement = (containerRect.height - joystick.offsetHeight) / 2;
            const distance = joystickCenter - containerCenter;
            
            // Calculate percentage from center (-1 to +1) using full movement range
            let percentage = distance / maxMovement - 0.02;
            
            // Clamp to valid range to ensure exactly -100 to +100
            percentage = Math.max(-1, Math.min(1, percentage));
            
            // Flip direction and scale: up = positive (forward), down = negative (backward)
            return Math.round(-percentage * 100);
        }
        
        function moveJoystick(e){
            const containerRect = joystickContainer.getBoundingClientRect();
            const maxY = containerRect.height - joystick.offsetHeight;
            let newY = e.clientY - containerRect.top - joystick.offsetHeight / 2;
            newY = Math.max(0, Math.min(maxY, newY));
            joystick.style.top = `${newY}px`;
        }
        
        var controlData = {setpoint: 0, input: 0, output: 0};
        const maxSpeed = 500;
        let websocket;
        const host = window.location.hostname;//"192.168.178.94"//
        
        function onWebSocketMessage(event){
            const data = JSON.parse(event.data);
            console.log("WebSocket message received:", data);
            if(data.hasOwnProperty('controlData')){
                controlData = data.controlData;
                updateDisplay(controlData);
            }
        }
        
        function initWebSocket(){
            websocket = new WebSocket("ws://" + host + ":81/");
            websocket.onopen = () => console.log("WebSocket connection opened");
            websocket.onclose = () => {
                console.log("WebSocket connection closed, attempting to reconnect");
                setTimeout(initWebSocket, 1000);
            };
            websocket.onerror = (error) => console.error("WebSocket error:", error);
            websocket.onmessage = onWebSocketMessage;
        }
        
        function onModeChanged(mode){
            fetch(`http://${host}/mode`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({mode: mode})
            })
            .then(response => response.json())
            .then(data => console.log('Mode updated:', data))
            .catch(error => console.error('Error updating mode:', error));
        }
        
        function onStopClicked(){
            fetch(`http://${host}/stop`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'}
            })
            .then(response => response.json())
            .then(data => console.log('Stop:', data))
            .catch(error => console.error('Error stopping:', error));
        }
        
        function sendSetpoint(setpoint){
            if(websocket && websocket.readyState === WebSocket.OPEN){
                websocket.send(JSON.stringify({setpoint: setpoint}));
            }
        }
        
        function updateDisplay(data){
            var setpointPercent = data.setpoint;
            var inputPercent = data.input;
            
            if(getSelectedMode() == 2 || getSelectedMode() == 3){
                setpointPercent = (data.setpoint * 100) / maxSpeed;
                inputPercent = (data.input * 100) / maxSpeed;
            }
            
            // Store data for graph using actual commanded setpoint
            addDataPoint(currentSetpoint, data.input, data.output);
            
            // Update bars
            document.getElementById("bar_setpoint").style.height = `${50 + (setpointPercent * 0.5)}%`;
            document.getElementById("bar_setpoint").innerHTML = data.setpoint;
            document.getElementById("bar_input").style.height = `${50 + (inputPercent * 0.5)}%`;
            document.getElementById("bar_input").innerHTML = data.input;
            document.getElementById("bar_output").style.height = `${50 + (data.output * 0.5)}%`;
            document.getElementById("bar_output").innerHTML = data.output;
            
            // Update graph if showing
            if(showGraph) {
                drawGraph();
            }
        }
        
        function fetchCurrentMode(){
            fetch(`http://${host}/mode`)
            .then(response => response.json())
            .then(data => setModeSelection(data.mode))
            .catch(error => console.error('Error fetching mode:', error));
        }
        
        function init(){
            initWebSocket();
            initModeSelector();
            setModeCallback(onModeChanged);
            setStopCallback(onStopClicked);
            initJoystick();
            
            setInterval(() => {
                var joystickValue = getJoystickValue();
                
                // Update joystick value display
                document.getElementById('joystick-value').textContent = joystickValue;
                
                // Scale for speed modes
                var scaledValue = joystickValue;
                if(getSelectedMode() == 2 || getSelectedMode() == 3){
                    scaledValue = (joystickValue * maxSpeed) / 100;
                }
                
                // Store the commanded setpoint
                currentSetpoint = scaledValue;
                
                sendSetpoint(scaledValue);
                updateDisplay(controlData);
            }, 100);
            
            fetchCurrentMode();
        }
        
        init();
    </script>
</body>
</html>